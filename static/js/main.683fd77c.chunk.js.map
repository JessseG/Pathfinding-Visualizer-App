{"version":3,"sources":["algorithms/Dijkstra.js","algorithms/Astar.js","components/Node.js","components/Pathfind.js","App.js","index.js"],"names":["Dijkstra","startNode","endNode","Grid","Y","X","visitedNodes","shortestPath","d","push","currentNode","probeRight","node","x","y","isWall","includes","probeDown","probeLeft","probeUp","i","length","j","k","nodeA","nodeB","dist","undefined","isStart","error","Astar","probeRight2","probeDown2","probeLeft2","probeUp2","frontier","frontier2","heuristic","h","tempDist","min","minNode","console","log","Node","isEnd","useState","wall","classes","className","id","startY","Math","floor","endX","endY","Pathfind","setGrid","grid","setG","setDijkstra","setAstar","DijkstraNodes","setDijkstraNodes","DijkstraPath","setDijkstraPath","AstarNodes","setAstarNodes","AstarPath","setAstarPath","useEffect","initializeGrid","Array","createSpots","setHeuristics","dijkstra1","astar1","distance","sqrt","pow","round","Number","EPSILON","Spot","this","random","printTarget","e","target","substring","draw","mouseDown","down","document","addEventListener","onmouseup","dijkstraX","astarX","reloadAlgorithms","removeEventListener","check1","test","getElementById","outputGrid","map","column","columnIndex","row","rowIndex","clearSearchSpace","dijkstraSpace","astarSpace","drawAstarNodes","setTimeout","drawAstarPath","onClick","drawDijkstraPath","window","location","reload","App","ReactDOM","render","StrictMode"],"mappings":"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","file":"static/js/main.683fd77c.chunk.js","sourcesContent":["import React from \"react\";\n\nfunction Dijkstra(startNode, endNode, Grid, Y, X) {\n  const visitedNodes = [];\n  const shortestPath = [];\n\n  startNode.d = 0;\n  visitedNodes.push(startNode);\n\n  let currentNode = startNode;\n\n  // ______________________________________________________________\n\n  function probeRight(node) {\n    // console.log(node);\n    if (\n      node.x <= X - 2 &&\n      !Grid[node.y][node.x + 1].isWall &&\n      !visitedNodes.includes(Grid[node.y][node.x + 1])\n    ) {\n      return true;\n    }\n  }\n  function probeDown(node) {\n    if (\n      node.y <= Y - 2 &&\n      !Grid[node.y + 1][node.x].isWall &&\n      !visitedNodes.includes(Grid[node.y + 1][node.x])\n    ) {\n      return true;\n    }\n  }\n  function probeLeft(node) {\n    if (\n      node.x >= 1 &&\n      !Grid[node.y][node.x - 1].isWall &&\n      !visitedNodes.includes(Grid[node.y][node.x - 1])\n    ) {\n      return true;\n    }\n  }\n  function probeUp(node) {\n    if (\n      node.y >= 1 &&\n      !Grid[node.y - 1][node.x].isWall &&\n      !visitedNodes.includes(Grid[node.y - 1][node.x])\n    ) {\n      return true;\n    }\n  }\n\n  // ______________________________________________________________\n\n  // probeRight\n  if (!Grid[startNode.y][startNode.x + 1].isWall) {\n    currentNode = Grid[startNode.y][startNode.x + 1];\n    currentNode.d = startNode.d + 1;\n    visitedNodes.push(currentNode);\n  }\n  // probeDown\n  if (!Grid[startNode.y + 1][startNode.x].isWall) {\n    currentNode = Grid[startNode.y + 1][startNode.x];\n    currentNode.d = startNode.d + 1;\n    visitedNodes.push(currentNode);\n  }\n  // probeLeft\n  if (!Grid[startNode.y][startNode.x - 1].isWall) {\n    currentNode = Grid[startNode.y][startNode.x - 1];\n    currentNode.d = startNode.d + 1;\n    visitedNodes.push(currentNode);\n  }\n  // probeUp\n  if (!Grid[startNode.y - 1][startNode.x].isWall) {\n    currentNode = Grid[startNode.y - 1][startNode.x];\n    currentNode.d = startNode.d + 1;\n    visitedNodes.push(currentNode);\n  }\n\n  let i = 1;\n  let node;\n\n  while (i < visitedNodes.length) {\n    node = visitedNodes[i];\n\n    // console.log(node);\n    if (probeRight(node)) {\n      Grid[node.y][node.x + 1].d = node.d + 1;\n      visitedNodes.push(Grid[node.y][node.x + 1]);\n      if (Grid[node.y][node.x + 1] === endNode) {\n        break;\n      }\n    }\n    if (probeDown(node)) {\n      Grid[node.y + 1][node.x].d = node.d + 1;\n      visitedNodes.push(Grid[node.y + 1][node.x]);\n      if (Grid[node.y + 1][node.x] === endNode) {\n        break;\n      }\n    }\n    if (probeLeft(node)) {\n      Grid[node.y][node.x - 1].d = node.d + 1;\n      visitedNodes.push(Grid[node.y][node.x - 1]);\n      if (Grid[node.y][node.x - 1] === endNode) {\n        break;\n      }\n    }\n    if (probeUp(node)) {\n      Grid[node.y - 1][node.x].d = node.d + 1;\n      visitedNodes.push(Grid[node.y - 1][node.x]);\n      if (Grid[node.y - 1][node.x] === endNode) {\n        break;\n      }\n    }\n\n    i++;\n  }\n\n  if (visitedNodes.includes(endNode)) {\n    let j = visitedNodes.length - 1;\n    let k = j - 1;\n\n    shortestPath.push(visitedNodes[j]);\n\n    let nodeA = visitedNodes[j];\n\n    let nodeB = visitedNodes[k];\n\n    let dist = nodeA.d;\n\n    while (true) {\n      // check Left\n      if (nodeA.x >= 1 && visitedNodes.includes(Grid[nodeA.y][nodeA.x - 1])) {\n        if (Grid[nodeA.y][nodeA.x - 1].d < dist) {\n          dist = Grid[nodeA.y][nodeA.x - 1].d;\n          nodeB = Grid[nodeA.y][nodeA.x - 1];\n        }\n      }\n      // check Down\n      if (\n        nodeA.y <= Y - 2 &&\n        visitedNodes.includes(Grid[nodeA.y + 1][nodeA.x])\n      ) {\n        if (Grid[nodeA.y + 1][nodeA.x].d < dist) {\n          dist = Grid[nodeA.y + 1][nodeA.x].d;\n          nodeB = Grid[nodeA.y + 1][nodeA.x];\n        }\n      }\n      // check Up\n      if (nodeA.y >= 1 && visitedNodes.includes(Grid[nodeA.y - 1][nodeA.x])) {\n        if (Grid[nodeA.y - 1][nodeA.x].d < dist) {\n          dist = Grid[nodeA.y - 1][nodeA.x].d;\n          nodeB = Grid[nodeA.y - 1][nodeA.x];\n        }\n      }\n      // check Right\n      if (\n        nodeA.x <= X - 2 &&\n        visitedNodes.includes(Grid[nodeA.y][nodeA.x + 1])\n      ) {\n        if (Grid[nodeA.y][nodeA.x + 1].d < dist) {\n          dist = Grid[nodeA.y][nodeA.x + 1].d;\n          nodeB = Grid[nodeA.y][nodeA.x + 1];\n        }\n      }\n\n      shortestPath.push(nodeB);\n      // console.log(nodeA);\n      // console.log(nodeB);\n\n      if (nodeB === undefined) {\n        break;\n      }\n\n      if (nodeB.isStart) {\n        break;\n      }\n\n      nodeA = nodeB;\n    }\n  }\n\n  return { visitedNodes, shortestPath, error: \"No path\" };\n}\n\nfunction distance(nodeA, nodeB) {\n  let distance = Math.sqrt(\n    Math.pow(nodeB.x - nodeA.x, 2) + Math.pow(nodeB.y - nodeA.y, 2)\n  );\n  distance = Math.round((distance + Number.EPSILON) * 100) / 100;\n  return distance;\n}\n\nexport default Dijkstra;\n","import React from \"react\";\n\nfunction Astar(startNode, endNode, Grid, Y, X) {\n  function probeRight(node) {\n    // console.log(node);\n    if (\n      node.x <= X - 2 &&\n      !Grid[node.y][node.x + 1].isWall &&\n      !visitedNodes.includes(Grid[node.y][node.x + 1])\n    ) {\n      return true;\n    }\n  }\n  function probeDown(node) {\n    if (\n      node.y <= Y - 2 &&\n      !Grid[node.y + 1][node.x].isWall &&\n      !visitedNodes.includes(Grid[node.y + 1][node.x])\n    ) {\n      return true;\n    }\n  }\n  function probeLeft(node) {\n    if (\n      node.x >= 1 &&\n      !Grid[node.y][node.x - 1].isWall &&\n      !visitedNodes.includes(Grid[node.y][node.x - 1])\n    ) {\n      return true;\n    }\n  }\n  function probeUp(node) {\n    if (\n      node.y >= 1 &&\n      !Grid[node.y - 1][node.x].isWall &&\n      !visitedNodes.includes(Grid[node.y - 1][node.x])\n    ) {\n      return true;\n    }\n  }\n\n  //________________________________________________________________________________\n\n  function probeRight2(node) {\n    // console.log(node);\n    if (\n      node.x <= X - 2 &&\n      !Grid[node.y][node.x + 1].isWall &&\n      !visitedNodes.includes(Grid[node.y][node.x + 1])\n    ) {\n      return true;\n    }\n  }\n  function probeDown2(node) {\n    if (\n      node.y <= Y - 2 &&\n      !Grid[node.y + 1][node.x].isWall &&\n      !visitedNodes.includes(Grid[node.y + 1][node.x])\n    ) {\n      return true;\n    }\n  }\n  function probeLeft2(node) {\n    if (\n      node.x >= 1 &&\n      !Grid[node.y][node.x - 1].isWall &&\n      !visitedNodes.includes(Grid[node.y][node.x - 1])\n    ) {\n      return true;\n    }\n  }\n  function probeUp2(node) {\n    if (\n      node.y >= 1 &&\n      !Grid[node.y - 1][node.x].isWall &&\n      !visitedNodes.includes(Grid[node.y - 1][node.x])\n    ) {\n      return true;\n    }\n  }\n\n  // ______________________________________________________________\n\n  const frontier = [];\n  const frontier2 = [];\n  const visitedNodes = [];\n  const shortestPath = [];\n\n  startNode.d = 0;\n  // startNode.h = distance(startNode, endNode);  // already calculated\n\n  visitedNodes.push(startNode);\n\n  let currentNode;\n\n  let heuristic = startNode.h;\n\n  let tempDist = 0;\n\n  // ______________________________________________________________\n\n  // probeRight\n  if (probeRight(startNode)) {\n    frontier2.push(Grid[startNode.y][startNode.x + 1]);\n    if (Grid[startNode.y][startNode.x + 1].h < heuristic) {\n      tempDist = startNode.d;\n      frontier.push(Grid[startNode.y][startNode.x + 1]);\n      heuristic = Grid[startNode.y][startNode.x + 1].h;\n      // console.log(Grid[startNode.y][startNode.x + 1]);\n      // console.log(\"probeRight\");\n    }\n  }\n  // probeDown\n  if (probeDown(startNode)) {\n    frontier2.push(Grid[startNode.y + 1][startNode.x]);\n    if (Grid[startNode.y + 1][startNode.x].h < heuristic) {\n      tempDist = startNode.d;\n      frontier.push(Grid[startNode.y + 1][startNode.x]);\n      heuristic = Grid[startNode.y + 1][startNode.x].h;\n      // console.log(Grid[startNode.y + 1][startNode.x]);\n      // console.log(\"probeDown\");\n    }\n  }\n  // probeLeft\n  if (probeLeft(startNode)) {\n    frontier2.push(Grid[startNode.y][startNode.x - 1]);\n    if (Grid[startNode.y][startNode.x - 1].h < heuristic) {\n      tempDist = startNode.d;\n      frontier.push(Grid[startNode.y][startNode.x - 1]);\n      heuristic = Grid[startNode.y][startNode.x - 1].h;\n      // console.log(Grid[startNode.y][startNode.x - 1]);\n      // console.log(\"probeLeft\");\n    }\n  }\n  // probeUp\n  if (probeUp(startNode)) {\n    frontier2.push(Grid[startNode.y - 1][startNode.x]);\n    if (Grid[startNode.y - 1][startNode.x].h < heuristic) {\n      tempDist = startNode.d;\n      frontier.push(Grid[startNode.y - 1][startNode.x]);\n      heuristic = Grid[startNode.y - 1][startNode.x].h;\n      // console.log(Grid[startNode.y - 1][startNode.x]);\n      // console.log(\"probeUp\");\n    }\n  }\n\n  if (frontier2[0] === undefined) {\n    return { visitedNodes, shortestPath, error: \"No path\" };\n  }\n\n  let min = frontier2[0].h;\n  let minNode = frontier2[0];\n\n  for (let i = 1; i < frontier2.length; i++) {\n    let h = frontier2[i].h;\n    if (h < min) {\n      min = h;\n      minNode = frontier2[i];\n    }\n  }\n\n  frontier.push(minNode);\n\n  if (frontier[frontier.length - 1] === undefined) {\n    console.log(\"broke\");\n    // console.log(frontier[frontier.length - 1]);\n\n    return { visitedNodes, shortestPath, error: \"No path\" };\n  }\n\n  // console.log(frontier[frontier.length - 1]);\n  frontier[frontier.length - 1].d = tempDist + 1;\n  visitedNodes.push(frontier[frontier.length - 1]);\n\n  let i = 1;\n  let node = visitedNodes[visitedNodes.length - 1];\n\n  // Astar\n  while (node !== null && node !== endNode) {\n    if (node === endNode) {\n      break;\n    }\n\n    node = visitedNodes[visitedNodes.length - 1];\n\n    // break;\n    heuristic = node.h;\n\n    // console.log(node);\n\n    if (probeRight(node)) {\n      if (Grid[node.y][node.x + 1].h < heuristic) {\n        tempDist = node.d;\n        frontier.push(Grid[node.y][node.x + 1]);\n        heuristic = Grid[node.y][node.x + 1].h;\n        // console.log(Grid[node.y][node.x + 1]);\n      }\n    }\n\n    if (probeDown(node)) {\n      if (Grid[node.y + 1][node.x].h < heuristic) {\n        tempDist = node.d;\n        frontier.push(Grid[node.y + 1][node.x]);\n        heuristic = Grid[node.y + 1][node.x].h;\n        // console.log(Grid[node.y + 1][node.x]);\n      }\n    }\n\n    if (probeLeft(node)) {\n      if (Grid[node.y][node.x - 1].h < heuristic) {\n        tempDist = node.d;\n        frontier.push(Grid[node.y][node.x - 1]);\n        heuristic = Grid[node.y][node.x - 1].h;\n      }\n    }\n\n    if (probeUp(node)) {\n      if (Grid[node.y - 1][node.x].h < heuristic) {\n        tempDist = node.d;\n        frontier.push(Grid[node.y - 1][node.x]);\n        heuristic = Grid[node.y - 1][node.x].h;\n      }\n    }\n\n    if (\n      !frontier[frontier.length - 1].isWall &&\n      !visitedNodes.includes(frontier[frontier.length - 1])\n    ) {\n      frontier[frontier.length - 1].d = tempDist + 1;\n      visitedNodes.push(frontier[frontier.length - 1]);\n      // console.log(\"astar\");\n\n      if (frontier[frontier.length - 1] === endNode) {\n        console.log(\"END\");\n        break;\n      }\n\n      i++;\n    } else {\n      let j = 0;\n\n      // alternate to dijkstras\n      while (node !== null && node !== undefined && node !== endNode) {\n        node = visitedNodes[j];\n\n        if (node === undefined) {\n          return { visitedNodes, shortestPath, error: \"No path\" };\n        }\n\n        if (probeRight2(node)) {\n          Grid[node.y][node.x + 1].d = node.d + 1;\n          visitedNodes.push(Grid[node.y][node.x + 1]);\n          // console.log(\"dijks\");\n          if (Grid[node.y][node.x + 1] === endNode) {\n            break;\n          }\n          if (Grid[node.y][node.x + 1].h < heuristic) {\n            node = Grid[node.y][node.x + 1];\n            break;\n          }\n        }\n        if (probeDown2(node)) {\n          Grid[node.y + 1][node.x].d = node.d + 1;\n          visitedNodes.push(Grid[node.y + 1][node.x]);\n          // console.log(\"dijks\");\n          if (Grid[node.y + 1][node.x] === endNode) {\n            break;\n          }\n          if (Grid[node.y + 1][node.x].h < heuristic) {\n            node = Grid[node.y + 1][node.x];\n            break;\n          }\n        }\n        if (probeLeft2(node)) {\n          Grid[node.y][node.x - 1].d = node.d + 1;\n          visitedNodes.push(Grid[node.y][node.x - 1]);\n          // console.log(\"dijks\");\n          if (Grid[node.y][node.x - 1] === endNode) {\n            break;\n          }\n          if (Grid[node.y][node.x - 1].h < heuristic) {\n            node = Grid[node.y][node.x - 1];\n            break;\n          }\n        }\n        if (probeUp2(node)) {\n          Grid[node.y - 1][node.x].d = node.d + 1;\n          visitedNodes.push(Grid[node.y - 1][node.x]);\n          // console.log(\"dijks\");\n          if (Grid[node.y - 1][node.x] === endNode) {\n            break;\n          }\n          if (Grid[node.y - 1][node.x].h < heuristic) {\n            node = Grid[node.y - 1][node.x];\n            break;\n          }\n        }\n        j++;\n      }\n\n      if (node === endNode) {\n        break;\n      }\n    }\n    if (node === endNode) {\n      break;\n    }\n  }\n\n  if (visitedNodes[i] === null) {\n    console.log(\"visitedNodes[i] is null\");\n  }\n\n  // retrace\n\n  if (visitedNodes.includes(endNode)) {\n    let j = visitedNodes.length - 1;\n    let k = j - 1;\n\n    shortestPath.push(visitedNodes[j]);\n\n    let nodeA = visitedNodes[j];\n\n    let nodeB = visitedNodes[k];\n\n    let dist = nodeA.d;\n\n    while (true) {\n      // break; // check Left\n      if (nodeA.x >= 1 && visitedNodes.includes(Grid[nodeA.y][nodeA.x - 1])) {\n        if (Grid[nodeA.y][nodeA.x - 1].d < dist) {\n          dist = Grid[nodeA.y][nodeA.x - 1].d;\n          nodeB = Grid[nodeA.y][nodeA.x - 1];\n        }\n      }\n      // check Down\n      if (\n        nodeA.y <= Y - 2 &&\n        visitedNodes.includes(Grid[nodeA.y + 1][nodeA.x])\n      ) {\n        if (Grid[nodeA.y + 1][nodeA.x].d < dist) {\n          dist = Grid[nodeA.y + 1][nodeA.x].d;\n          nodeB = Grid[nodeA.y + 1][nodeA.x];\n        }\n      }\n      // check Up\n      if (nodeA.y >= 1 && visitedNodes.includes(Grid[nodeA.y - 1][nodeA.x])) {\n        if (Grid[nodeA.y - 1][nodeA.x].d < dist) {\n          dist = Grid[nodeA.y - 1][nodeA.x].d;\n          nodeB = Grid[nodeA.y - 1][nodeA.x];\n        }\n      }\n      // check Right\n      if (\n        nodeA.x <= X - 2 &&\n        visitedNodes.includes(Grid[nodeA.y][nodeA.x + 1])\n      ) {\n        if (Grid[nodeA.y][nodeA.x + 1].d < dist) {\n          dist = Grid[nodeA.y][nodeA.x + 1].d;\n          nodeB = Grid[nodeA.y][nodeA.x + 1];\n        }\n      }\n\n      shortestPath.push(nodeB);\n      // console.log(nodeA);\n      // console.log(nodeB);\n\n      if (nodeB === undefined) {\n        break;\n      }\n\n      if (nodeB.isStart) {\n        break;\n      }\n\n      nodeA = nodeB;\n    }\n  }\n\n  return { visitedNodes, shortestPath, error: \"No path\" };\n}\n\nfunction distance(nodeA, nodeB) {\n  let distance = Math.sqrt(\n    Math.pow(nodeB.x - nodeA.x, 2) + Math.pow(nodeB.y - nodeA.y, 2)\n  );\n  distance = Math.round((distance + Number.EPSILON) * 100) / 100;\n  return distance;\n}\n\nexport default Astar;\n","import React, { useState, useEffect } from \"react\";\nimport \"./Node.css\";\n\nconst Node = ({ x, y, isStart, isEnd, isWall }) => {\n  const [wall, setWall] = useState(isWall);\n  const [mouseDown, setMouseDown] = useState(false);\n  const [mouseEnter, setMouseEnter] = useState(false);\n  const [isDrawing, setIsDrawing] = useState(false);\n\n  // node = document.getElementById(`node-${y}-${x}`);\n\n  // useEffect(() => {\n  //   changeWall();\n  // }, [mouseDown, mouseEnter]);\n\n  // document.getElementById(\"grid\").onmousedown = () => {\n  //   setIsDrawing(true);\n  //   console.log(\"down\");\n  // };\n\n  // document.getElementById(\"grid\").onmouseup = () => {\n  //   setIsDrawing(false);\n  //   console.log(\"up\");\n  // };\n\n  const startDrawing = () => {\n    setIsDrawing(true);\n  };\n\n  const stopDrawing = () => {\n    setIsDrawing(false);\n  };\n\n  const draw = ({ nativeEvent }) => {\n    let id = nativeEvent.target.id;\n    console.log(id);\n\n    if (id === null) {\n      return;\n    }\n    console.log(id.substring(5, 7));\n    console.log(id.substring(8, 10));\n\n    let Y = id.substring(5, 7);\n    let X = id.substring(8, 10);\n\n    document.getElementById(\"grid\").onmousedown = () => {\n      // console.log(nativeEvent.target.id);\n      document.getElementById(`node-${Y}-${X}`).className = \"node node-wall\";\n    };\n  };\n\n  const changeWall = () => {\n    setWall(!wall);\n    console.log(\"paint\");\n  };\n\n  //______________________________________________________________\n\n  // const mouseEntering = () => {\n  //   setMouseEnter(true);\n  //   // changeWall();\n  // };\n\n  //____________________________________________________________\n\n  const classes = isStart\n    ? \"node-start\"\n    : isEnd\n    ? \"node-end\"\n    : wall\n    ? \"node-wall\"\n    : \"\";\n\n  return (\n    <div\n      className={`node ${classes}`}\n      id={`node-${y}-${x}`}\n      // onMouseEnter={draw}\n    ></div>\n  );\n};\n\nexport default Node;\n","import React, { useState, useEffect } from \"react\";\nimport DepthFirst from \"../algorithms/DepthFirst\";\nimport Dijkstra from \"../algorithms/Dijkstra\";\nimport Astar from \"../algorithms/Astar\";\nimport Node from \"./Node\";\nimport \"./Pathfind.css\";\n\n// const X = 160;\n// const Y = 100;\n\nconst X = 100;\nconst Y = 50;\n\n// const X = 40; // columns\n// const Y = 25; // rows\n\nconst startX = 3;\nconst startY = Math.floor(Math.floor(Y) / 2);\nconst endX = Math.floor(X) - 3;\nconst endY = Math.floor(Y) - 2;\n\n// const startX = Math.floor(X / 5);\n// const startY = Math.floor(Y / 2);\n// const endX = Math.floor((X * 4) / 5);\n// const endY = Math.floor(Y / 2);\n\nconst Pathfind = () => {\n  const [Grid, setGrid] = useState([]);\n  var [grid, setG] = useState([]);\n\n  const [dijkstra, setDijkstra] = useState([]);\n  const [astar, setAstar] = useState([]);\n\n  const [DijkstraNodes, setDijkstraNodes] = useState([]);\n  const [DijkstraPath, setDijkstraPath] = useState([]);\n\n  const [AstarNodes, setAstarNodes] = useState([]);\n  const [AstarPath, setAstarPath] = useState([]);\n\n  // const [mouseDown, setMouseDown] = useState(false);\n  const [mouseOver, setMouseOver] = useState(false);\n  const [isDrawing, setDrawing] = useState(false);\n\n  // var grid;\n\n  var startNode;\n  var endNode;\n\n  useEffect(() => {\n    initializeGrid();\n  }, []);\n\n  const initializeGrid = () => {\n    grid = new Array(X);\n\n    for (let i = 0; i < Y; i++) {\n      grid[i] = new Array(Y);\n    }\n\n    createSpots(grid);\n    setHeuristics(grid);\n\n    startNode = grid[startY][startX];\n    endNode = grid[endY][endX];\n\n    startNode.isWall = false;\n    endNode.isWall = false;\n\n    setG(grid);\n\n    setGrid(grid);\n\n    // setListeners(Grid);\n\n    const dijkstra1 = Dijkstra(startNode, endNode, grid, Y, X);\n    const astar1 = Astar(startNode, endNode, grid, Y, X);\n\n    setDijkstraNodes(dijkstra1.visitedNodes);\n    setDijkstraPath(dijkstra1.shortestPath);\n\n    setAstarNodes(astar1.visitedNodes);\n    setAstarPath(astar1.shortestPath);\n\n    setDijkstra(dijkstra1);\n    setAstar(astar1);\n  };\n\n  function reloadAlgorithms() {\n    const dijkstraX = Dijkstra(startNode, endNode, grid, Y, X);\n    const astarX = Astar(startNode, endNode, grid, Y, X);\n\n    setDijkstraNodes(dijkstraX.visitedNodes);\n    setDijkstraPath(dijkstraX.shortestPath);\n\n    setAstarNodes(astarX.visitedNodes);\n    setAstarPath(astarX.shortestPath);\n  }\n\n  function distance(nodeA, nodeB) {\n    let distance = Math.sqrt(\n      Math.pow(nodeB.x - nodeA.x, 2) + Math.pow(nodeB.y - nodeA.y, 2)\n    );\n    distance = Math.round((distance + Number.EPSILON) * 100) / 100;\n    return distance;\n  }\n\n  function Spot(y, x) {\n    this.x = x;\n    this.y = y;\n    this.d = 0;\n    this.h = 0;\n    this.isStart = this.x === startX && this.y === startY;\n    this.isEnd = this.x === endX && this.y === endY;\n    this.isWall = false;\n    if (Math.random(1) < 0.35) {\n      this.isWall = true;\n    }\n  }\n\n  const createSpots = (grid) => {\n    for (let x = 0; x < X; x++) {\n      for (let y = 0; y < Y; y++) {\n        grid[y][x] = new Spot(y, x);\n      }\n    }\n  };\n\n  const setHeuristics = (grid) => {\n    for (let x = 0; x < X; x++) {\n      for (let y = 0; y < Y; y++) {\n        grid[y][x].h = distance(grid[y][x], grid[endY][endX]);\n      }\n    }\n  };\n\n  function printTarget(e) {\n    let id = e.target.id;\n    if (e === undefined || e === null || e === \"\" || id === null || id === \"\")\n      return;\n    let validate = id.substring(0, 4);\n    if (validate !== \"node\") return;\n    // console.log(e.target.id);\n    draw(e);\n  }\n\n  let mouseDown = false;\n\n  function down(e) {\n    console.log(\"down\");\n    mouseDown = true;\n    printTarget(e);\n\n    if (mouseDown) {\n      document.addEventListener(\"mouseover\", printTarget);\n    }\n  }\n\n  useEffect(() => {\n    document.addEventListener(\"mousedown\", down);\n\n    document.onmouseup = () => {\n      console.log(\"up\");\n      mouseDown = false;\n      reloadAlgorithms();\n      document.removeEventListener(\"mouseover\", printTarget);\n    };\n\n    // return () => {\n    //   document.removeEventListener(\"mouseover\", printTarget);\n    // };\n  }, []);\n\n  // __________________________________________________________\n\n  // const [mouseDown, setMouseDown] = useState(true);\n\n  // const handleDraw = useCallback(\n  //   (event) => {\n  //     if (event.key === \"Escape\") {\n  //       setMouseDown(true);\n  //     }\n  //   },\n  //   [setMouseDown]\n  // );\n\n  // useEffect(() => {\n  //   if (!mouseDown) {\n  //     window.removeEventListener(\"keyup\", handleDraw);\n  //   } else {\n  //     window.addEventListener(\"keyup\", handleDraw);\n  //   }\n\n  //   return () => window.removeEventListener(\"keyup\", handleDraw);\n  // }, [mouseDown, handleDraw]);\n\n  // _________________________________________________________________\n\n  let wallToggle = 0;\n\n  const draw = (e) => {\n    let id = e.target.id;\n\n    let check1 = id.substring(6, 7);\n\n    let x;\n    let y;\n\n    if (check1 === \"-\") {\n      x = id.substring(5, 6);\n      y = id.substring(7);\n    } else if (/^\\d+$/.test(check1)) {\n      x = id.substring(5, 7);\n      y = id.substring(8);\n    }\n    // console.log(x + \"-\" + y);\n    // let X = id.substring(8, 10);\n\n    if ((x == startX && y == startY) || (x == endX && y == endY)) {\n      return;\n    }\n\n    // grid[y][x].isWall = true;\n    grid[y][x].isWall = !grid[y][x].isWall;\n\n    // setBoard(true);\n    // console.log(document.getElementById(id).className);\n\n    if (document.getElementById(id).className === \"node \") {\n      document.getElementById(id).className = \"node node-wall\";\n    } else if (document.getElementById(id).className === \"node node-wall\") {\n      document.getElementById(id).className = \"node \";\n    }\n\n    // document.getElementById(id).style = \"border: 1px solid rgb(53, 53, 53)\";\n  };\n\n  const outputGrid = (\n    <div>\n      {Grid.map((column, columnIndex) => {\n        return (\n          <div key={columnIndex} className=\"rowWrap\">\n            {column.map((row, rowIndex) => {\n              const { isStart, isEnd, isWall } = row;\n\n              return (\n                <Node\n                  x={columnIndex}\n                  y={rowIndex}\n                  isStart={isStart}\n                  isEnd={isEnd}\n                  isWall={isWall}\n                  key={rowIndex}\n                />\n              );\n            })}\n          </div>\n        );\n      })}\n    </div>\n  );\n\n  const clearSearchSpace = () => {\n    if (DijkstraNodes.length > 1) {\n      let dijkstraSpace = document.getElementById(\n        `node-${DijkstraNodes[1].x}-${DijkstraNodes[1].y}`\n      ).className;\n      if (\n        dijkstraSpace === \"node node-visited\" ||\n        dijkstraSpace === \"node node-shortPath\"\n      ) {\n        for (let k = 0; k < DijkstraNodes.length; k++) {\n          if (!DijkstraNodes[k].isStart && !DijkstraNodes[k].isEnd) {\n            document.getElementById(\n              `node-${DijkstraNodes[k].x}-${DijkstraNodes[k].y}`\n            ).className = \"node \";\n          }\n        }\n      }\n    }\n\n    let astarSpace = document.getElementById(\n      `node-${AstarNodes[1].x}-${AstarNodes[1].y}`\n    ).className;\n    if (\n      astarSpace === \"node node-visited\" ||\n      astarSpace === \"node node-shortPath\"\n    ) {\n      for (let k = 0; k < AstarNodes.length; k++) {\n        if (!AstarNodes[k].isStart && !AstarNodes[k].isEnd) {\n          document.getElementById(\n            `node-${AstarNodes[k].x}-${AstarNodes[k].y}`\n          ).className = \"node \";\n        }\n      }\n    }\n  };\n\n  function drawDijkstraNodes() {\n    // iterates through all visited nodes\n    // let x = 0;\n\n    clearSearchSpace();\n\n    let i;\n    for (i = 0; i < DijkstraNodes.length; i++) {\n      const node = DijkstraNodes[i];\n      setTimeout(() => {\n        if (!node.isStart && !node.isEnd) {\n          document.getElementById(`node-${node.x}-${node.y}`).className =\n            \"node node-visited\";\n          // document.getElementById(`node-${node.x}-${node.y}`).style =\n          //   \"border: 1px solid white\";\n          // console.log(node);\n        }\n      }, i * 5);\n      // x++;\n    }\n    setTimeout(() => drawDijkstraPath(), i * 5);\n  }\n\n  function drawDijkstraPath() {\n    for (let i = 0; i < DijkstraPath.length; i++) {\n      const node = DijkstraPath[i];\n      setTimeout(() => {\n        if (!node.isStart && !node.isEnd) {\n          document.getElementById(`node-${node.x}-${node.y}`).className =\n            \"node node-shortPath\";\n          // document.getElementById(`node-${node.x}-${node.y}`).style =\n          //   \"border: 1px solid rgb(255, 208, 0)\";\n        }\n      }, i * 18);\n    }\n  }\n\n  function drawAstarNodes() {\n    // iterates through all visited nodes\n    // let x = 0;\n\n    clearSearchSpace();\n\n    let i;\n    for (i = 0; i < AstarNodes.length; i++) {\n      const node = AstarNodes[i];\n      setTimeout(() => {\n        if (!node.isStart && !node.isEnd) {\n          document.getElementById(`node-${node.x}-${node.y}`).className =\n            \"node node-visited\";\n          // console.log(node);\n        }\n      }, i * 5);\n      // x++;\n    }\n    setTimeout(() => drawAstarPath(), i * 5);\n  }\n\n  function drawAstarPath() {\n    for (let i = 0; i < AstarPath.length; i++) {\n      const node = AstarPath[i];\n      setTimeout(() => {\n        if (!node.isStart && !node.isEnd) {\n          document.getElementById(`node-${node.x}-${node.y}`).className =\n            \"node node-shortPath\";\n        }\n      }, i * 18);\n    }\n  }\n\n  // function resetBoard() {\n\n  // }\n\n  return (\n    <div className=\"pathfinder\">\n      <div className=\"centerGrid\">\n        <button id=\"visualize-Btn\" onClick={drawDijkstraNodes}>\n          Dijkstra\n        </button>\n        <button id=\"visualize-Btn\" onClick={drawAstarNodes}>\n          Astar\n        </button>\n        <button id=\"visualize-Btn\" onClick={drawAstarNodes}>\n          Depth\n        </button>\n        <button id=\"reset-Btn\" onClick={() => window.location.reload(false)}>\n          Reset\n        </button>\n        <div id=\"grid\">{outputGrid}</div>\n        {/* <DepthFirst /> */}\n      </div>\n    </div>\n  );\n};\n\nexport default Pathfind;\n","import React from \"react\";\nimport \"./App.css\";\nimport Pathind from \"./components/Pathfind\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <h1>Pathfinder</h1>\n      <Pathind />\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}